<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Транспортная задача</title>
</head>
<style>
    #numOfConsumers {
        border-color: rgb(219, 219, 219);
        padding: 5px;
        margin: 2px;
        border-radius: 3px;
        outline: 0;
        width: 100px;
    }

    #numOfProducers {
        border-color: rgb(219, 219, 219);
        padding: 5px;
        margin: 2px;
        border-radius: 3px;
        outline: 0;
        width: 100px;
    }

    .matrixField,
    .purpleField,
    .pinkField {
        border-color: rgb(219, 219, 219);
        padding: 5px;
        margin: 2px;
        border-radius: 3px;
        outline: 0;
        height: 25px;
        width: 25px;
    }

    .purpleField {
        background-color: purple;
    }

    .pinkField {
        background-color: plum;
    }
</style>

<body>
    <input id="numOfConsumers" placeholder="Количество потребителей"></input>
    <input id="numOfProducers" placeholder="Количество производителей"></input>

    <button id="submitBtn">Создать матрицу</button>
    <button id="calcBtn" disabled>Рассчитать</button>
    <div id="matrix"></div>
    <script>
        const numOfCons = document.getElementById("numOfConsumers");
        const numOfProd = document.getElementById("numOfProducers");
        const submitBtn = document.getElementById("submitBtn");

        const taxesValues = [];
        const consValues = [];
        const prodsValues = [];
        const matrixCells = [];         // двойной массив со значениями (какой поставщик сколько кому везет товару)
        const potentialsClmn = [];      // потенциалы, которые слева пишем обычно
        const potentialsStr = [];       // потенциалы, которые пишем сверху
        const matrPotentials = [];      // разница суммы потенциалов и тарифа для каждой [пустой] ячейки

        const check = () => {               //проверка на сбалансированность
            let sumCons = 0;
            let sumProds = 0;

            consValues.forEach((value) => {
                sumCons += value;
            });
            prodsValues.forEach((value) => {
                sumProds += value;
            })
            console.log("sumCons", sumCons);
            console.log("sumProds", sumProds)

            if (sumCons === sumProds) {
                return true;
            } else {
                return false;
            }
        }

        const fillCells = (matrix, cons, prods) => {
            for (let i = 0; i < prods.length; i++) {
                const arr = [];
                for (let j = 0; j < cons.length; j++) {
                    arr.push({
                        i,
                        j,
                        value: 0,
                        tax: matrix[i * cons.length + j].value - 0,
                        potentialDiff: 0
                    })
                }
                matrixCells.push(arr);
            }

            console.log("matrixCells ", matrixCells);
            cons.forEach((input) => consValues.push(input.value - 0));
            console.log("Cons", consValues);
            prods.forEach((input) => prodsValues.push(input.value - 0));
            console.log("Prods", prodsValues);

            if (!check()) {
                alert("Задача несбалансированная!");
            }
        }

        // служебные функции

        const findMinValueElem = matrix => {
            let minElem = { i: 0, j: 0, value: 1000, tax: 0 };
            matrix.forEach((arr, i) => arr.forEach((elem, j) => {
                let num = elem.value - 0;
                if (num < minElem.value) minElem = { i: i, j: j, value: num };
            }))
            console.log("elem with min value ", minElem);
            return minElem;
        }

        const findMaxValueElem = matrix => {
            let maxElem = { i: 0, j: 0, value: 0, tax: 0 };
            matrix.forEach((arr, i) => arr.forEach((value, j) => {
                let num = value - 0;
                if (num > maxElem.value) maxElem = { i: i, j: j, value: num };
            }))
            console.log("max ", maxElem);
            return maxElem;
        }

        const findMinTaxElem = matrix => {
            let minElem = { i: 0, j: 0, value: 0, tax: 1000 };
            matrix.forEach((arr, i) => arr.forEach((elem, j) => {
                let num = elem.tax - 0;
                if (num < minElem.tax) minElem = { i, j, value: elem.value - 0, tax: num };
            }))
            console.log("elem with min value ", minElem);
            return minElem;
        }

        const findMinElemIndex = (array, minTax) => {
            let minElem;
            array.forEach((elem, index) => { if (elem.value == minTax) minElem = index; });
            console.log("minElem ", minElem);
            return minElem;
        }

        // опорный план
        const createReferencePlan = () => {
            const prodsValuesCopy = prodsValues.slice();
            const consValuesCopy = consValues.slice();
            let matrixCellsCopy = [];
            matrixCells.forEach(arr => {
                const newArr = arr.slice();
                matrixCellsCopy.push(newArr);
            });

            let sumProds;
            let sumCons;

            do {
                const minTaxCell_1 = findMinTaxElem(matrixCellsCopy);
                const i = minTaxCell_1.i;
                const j = minTaxCell_1.j;
                const prod = prodsValuesCopy[i]
                const con = consValuesCopy[j]
                const value = prod < con ? prod : con;
                matrixCells[i][j].value = value;
                prodsValuesCopy[i] -= value;
                consValuesCopy[j] -= value;
                sumProds = prodsValuesCopy.reduce(
                    (accumulator, value) => accumulator + value, 0
                );
                sumCons = consValuesCopy.reduce(
                    (accumulator, value) => accumulator + value, 0
                );
                matrixCellsCopy[i][j] = {};
            } while (sumProds != 0 || sumCons != 0)

            // if() - сделать проверку на  m + n - 1
            console.log("Опорный план: ", matrixCells);
        }

        const findPotentials = () => {
            potentialsClmn[0] = 0;
            matrixCells[0].forEach(elem => {
                if (elem.value != 0) { potentialsStr[elem.j] = elem.tax - 0 }
            });

            const max = matrixCells.length > matrixCells[0].length ? matrixCells.length : matrixCells[0].length;
            for (let k = 0; k < max; k++) {
                potentialsStr.forEach((potential, clmnNum) => {
                    matrixCells.forEach((arr, strNum) => {
                        if (arr[clmnNum].value) {
                            potentialsClmn[strNum] = arr[clmnNum].tax - potentialsStr[clmnNum];
                        }
                    });
                });
                potentialsClmn.forEach((potential, strNum) => {
                    matrixCells[strNum].forEach((elem, clmnNum) => {
                        if (elem.value != 0) potentialsStr[clmnNum] = elem.tax - potentialsClmn[strNum];
                    })
                })
            }

            console.log("potentialsStr ", potentialsStr);
            console.log("potentialsClmn ", potentialsClmn);
        }

        const calcPotentialDifference = () => {
            matrixCells.forEach((str, strNum) => str.forEach(
                elem => elem.potentialDiff = potentialsClmn[elem.i] + potentialsStr[elem.j] - elem.tax));
            let maxPotentialDiffElem = matrixCells[0][0];
            matrixCells.forEach(arr => arr.forEach(elem => {
                if (elem.potentialDiff > maxPotentialDiffElem.potentialDiff) maxPotentialDiffElem = elem;
            }));
            console.log("maxPotentialDiffElem ", maxPotentialDiffElem);
            return maxPotentialDiffElem;
        }

        const makeContour = element => {
            const contour = [];
            matrixCells.forEach(arr => {
                const newArr = arr.slice();
                contour.push(newArr);
            });

            const max = matrixCells.length > matrixCells[0].length ? matrixCells.length : matrixCells[0].length;
            for (let k = 0; k < max; k++) {
                contour.forEach((str, strNum) => {
                    if (strNum != element.i) {
                        let counterElemsInStr = 0;
                        str.forEach(elem => {
                            if (elem)
                                if (elem.value) counterElemsInStr++;
                        })
                        if (counterElemsInStr < 2) contour[strNum] = [];
                    }
                });

                let clmns = [];
                for (let clmnNum = 0; clmnNum < contour[0].length; clmnNum++) {
                    clmns.push([])
                    for (let strNum = 0; strNum < contour.length; strNum++) {
                        if (contour[strNum][clmnNum]) {
                            if (contour[strNum][clmnNum].value != 0) {
                                clmns[clmnNum].push(contour[strNum][clmnNum]);
                            }
                        }
                    }
                }
                clmns.forEach((clmn, clmnNum) => {
                    if (clmn.length < 2) contour.forEach(str => {
                        if (clmnNum != element.j) {
                            str[clmnNum] = null;
                        }
                    });
                })
            }

            let finalContour = [];
            contour.flat().forEach(elem => { if (elem) finalContour.push(elem) });
            console.log("Contour ", finalContour);
            return finalContour;
        }

        const calcBtn = document.getElementById("calcBtn");
        calcBtn.addEventListener('click', () => {
            let inputs = document.querySelectorAll('.matrixField');
            let cons = document.querySelectorAll('.pinkField');
            let prods = document.querySelectorAll('.purpleField');
            fillCells(inputs, cons, prods);
            console.log("matrixCells ", matrixCells);

            createReferencePlan();
            findPotentials();
            const maxPotentialDiffElem = calcPotentialDifference();
            const contour = makeContour(maxPotentialDiffElem);
            
        });

        submitBtn.addEventListener('click', e => {
            if (numOfCons.value && numOfProd.value) {
                for (let i = 0; i <= numOfProd.value; i++) {                //созданы поля для заполнения 
                    for (let j = 0; j <= numOfCons.value; j++) {
                        if (i != numOfProd.value || j != numOfCons.value) {
                            const input = document.createElement('input');
                            document.getElementById('matrix').appendChild(input);
                            if (j == numOfCons.value && i != numOfProd.value) {
                                input.setAttribute("class", "purpleField");
                            } else if (i == numOfProd.value && j != numOfCons.value) {
                                input.setAttribute("class", "pinkField");
                            } else {
                                input.setAttribute("class", "matrixField");
                            }
                        }
                    }
                    document.getElementById('matrix').innerHTML += '<br>';
                }
            }
            calcBtn.disabled = false;
            e.target.disabled = true;
        });

    </script>
</body>

</html>